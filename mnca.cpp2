#include <raylib.h>

#include "types.h2"
#include "config.h2"

Cell: type = {
  public position: vec2<float> = (0.0f, 0.0f);
  public velocity: vec2<float> = (0.0f, 0.0f);

  color_num: u8 = 0;
  cell_iter_index: u32 = 0;

  operator=: (out this, new_x: float, new_y: float, config: Config) = {
    position = vec2<float>(new_x, new_y);
    color_num = random_value<u8>(0 as u8, config.colors_number - 1);
  }

  operator=: (out this, in that) = {
  }

  update: (inout this, config: Config) = {
    friction := 0.8f;
    gravity := 0.0f;

    velocity.x *= friction;
    velocity.y *= friction;
    velocity.y += gravity;

    vel_len := std::sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
    max_vel_len : const _ = 1.0f;
    if vel_len > max_vel_len {
      velocity.x *= max_vel_len / vel_len;
      velocity.y *= max_vel_len / vel_len;
    }

    cell_counter := 0; while cell_counter < cells.ssize() / 4 next cell_counter += 1 {
      other : const _ = cells[cell_iter_index % cells.size()];
      cell_iter_index = (cell_iter_index + 1) % cells.size();

      if this& != other& {
        dx := other.position.x - position.x;
        dy := other.position.y - position.y;

        dx = std::fmod(dx + 1.5f * window_width, window_width) - 0.5f * window_width;
        dy = std::fmod(dy + 1.5f * window_height, window_height) - 0.5f * window_height;

        dist := std::sqrt(dx * dx + dy * dy);

        if dist < 0.001f || dist > 100.0f {
          continue;
        }

        // might have some calculation bugs
        dist2 := dist * dist;

        sfx := dx / (dist2); 
        sfy := dy / (dist2); 

        separation_max : const _ = 0.8f;
        sfx = std::clamp(sfx, -separation_max, separation_max);
        sfy = std::clamp(sfy, -separation_max, separation_max);

        velocity.x -= sfx;
        velocity.y -= sfy;

        damping := 0.4f;
        force := config.attraction_matrix[color_num][other.color_num] / damping;
        fx := (dx / dist2) * force;
        fy := (dy / dist2) * force;

        force_max : const _ = 0.1f;
        fx = std::clamp(fx, -force_max, force_max);
        fy = std::clamp(fy, -force_max, force_max);
            
        velocity.x += fx;
        velocity.y += fy;

      }
    }

    position.x += velocity.x;
    position.y += velocity.y;

    if position.x < 0 {
      position.x += window_width;
    }

    if position.x > window_width {
      position.x -= window_width;
    }

    if position.y < 0 {
      position.y += window_height;
    }

    if position.y > window_height {
      position.y -= window_height;
    }

    if mouse_x.has_value() && mouse_y.has_value()
    {
      dx := mouse_x.value() - position.x;
      dy := mouse_y.value() - position.y;
      distance := std::sqrt(dx * dx + dy * dy);
      force := 1 / (distance + 1);
      velocity.x += dx * force;
      velocity.y += dy * force;

      color_num = (color_num + 1) % config.colors_number;
    }
  }

  draw: (in this, config: Config) = {
    color: Color = config.all_colors[color_num];
    DrawCircle(position.x, position.y, 2.0f, color);
  }
}

cells: std::vector<Cell> = ();

window_width: int = 800;
window_height: int = 600;

mouse_x: std::optional<int> = ();
mouse_y: std::optional<int> = ();

create_random_cell: (config: Config) -> Cell = {
  rw := cpp2::unsafe_narrow<float>(GetRandomValue(0, window_width));
  rh := cpp2::unsafe_narrow<float>(GetRandomValue(0, window_height));
  return Cell(rw as float, rh as float, config);
}

main: () = {
  window_name := "Hello, cppfront";
  InitWindow(window_width, window_height, window_name);
  SetTargetFPS(170);

  config := Config();
  gui := GUI();

  config.attraction_matrix = config.generate_attraction_matrix(config.colors_number);

  std::cout << "Hello, cppfront!\n";

  cell_num := 200; while cell_num > 0 next cell_num -= 1 {    
    cells.push_back(create_random_cell(config));
  }

  frame: u64 = 0;

  while !WindowShouldClose()
  {
    frame += 1;
    for cells do (inout cell) 
    {
      cell.update(config);

      if frame % 100000 == 0
      {
        cell.print_xy();
      }
    }

    window_width = GetRenderWidth();
    window_height = GetRenderHeight();

    if !IsMouseButtonDown(MOUSE_BUTTON_LEFT)
    {
      mouse_x.reset();
      mouse_y.reset();
    } 
    else
    {
      mouse_x = GetMouseX();
      mouse_y = GetMouseY();
    }

    if IsKeyDown(KEY_R) || IsKeyDown(KEY_SPACE)
    {
      cells.push_back(create_random_cell(config));
    }

    if IsMouseButtonDown(MOUSE_BUTTON_RIGHT)
    {
      cell := Cell(cpp2::unsafe_narrow<float>(GetMouseX()), cpp2::unsafe_narrow<float>(GetMouseY()), config);
      cells.push_back(cell);
    }

    BeginDrawing();
    //DrawRectangle(0, 0, window_width, window_height, ColorAlpha(BLACK, 0.5f));
    DrawRectangle(0, 0, window_width, window_height, BLACK);

    for cells do (in cell) {
      cell.draw(config);
    }
    gui.draw(config);

    EndDrawing();
  }
}

print_xy: (cell: Cell) = {
  std::cout << "cell.position = " << cell.position << "\n";
}
