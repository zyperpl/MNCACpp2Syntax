#include <raylib.h>

#include <thread>
#include <atomic>
#include <mutex>
#include <shared_mutex>

#include "types.h2"
#include "config.h2"

Cell: type = {
  public position: vec2<float> = (0.0f, 0.0f);
  public velocity: vec2<float> = (0.0f, 0.0f);

  color_num: u8 = 0;
  cell_iter_index: u32 = 0;

  operator=: (out this, move other) = {
    position = other.position;
    velocity = other.velocity;
    color_num = other.color_num;
    cell_iter_index = other.cell_iter_index;
  }

  operator=: (out this, new_x: float, new_y: float, config: Config) = {
    position = vec2<float>(new_x, new_y);
    color_num = random_value<u8>(0 as u8, config.colors_number - 1);
  }

  update: (inout this, config: Config) = {
    friction := 0.8f;
    gravity := 0.0f;

    velocity.x *= friction;
    velocity.y *= friction;
    velocity.y += gravity;

    vel_len := std::sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
    max_vel_len : const _ = 1.0f;
    if vel_len > max_vel_len {
      velocity.x *= max_vel_len / vel_len;
      velocity.y *= max_vel_len / vel_len;
    }

    cell_counter := 0; while cell_counter < cells.ssize() / 4 next cell_counter += 1 {
      other := cells.at(cell_iter_index)&; // is it a reference?
      cell_iter_index = (cell_iter_index + 1) % cells.size();

      if this& != other {
        dx := other*.position.x - position.x;
        dy := other*.position.y - position.y;

        dx = std::fmod(dx + 1.5f * window_width, window_width) - 0.5f * window_width;
        dy = std::fmod(dy + 1.5f * window_height, window_height) - 0.5f * window_height;

        dist := std::sqrt(dx * dx + dy * dy);

        if dist < 0.001f || dist > 80.0f {
          continue;
        }

        // might have some calculation bugs
        dist2 := dist * dist;

        sfx := dx / (dist2); 
        sfy := dy / (dist2); 

        separation_max : const _ = 0.8f;
        sfx = std::clamp(sfx, -separation_max, separation_max);
        sfy = std::clamp(sfy, -separation_max, separation_max);

        velocity.x -= sfx;
        velocity.y -= sfy;

        damping := 0.4f;
        force := config.attraction_matrix[color_num][other*.color_num] / damping;
        fx := (dx / dist2) * force;
        fy := (dy / dist2) * force;

        force_max : const _ = 0.1f;
        fx = std::clamp(fx, -force_max, force_max);
        fy = std::clamp(fy, -force_max, force_max);
            
        velocity.x += fx;
        velocity.y += fy;

      }
    }

    // TODO: unique lock?
    position.x += velocity.x;
    position.y += velocity.y;

    if position.x < 0 {
      position.x += window_width;
    }

    if position.x > window_width {
      position.x -= window_width;
    }

    if position.y < 0 {
      position.y += window_height;
    }

    if position.y > window_height {
      position.y -= window_height;
    }
  }

  draw: (in this, config: Config) = {
    // TODO: shared lock?
    color: Color = config.all_colors[color_num];
    DrawCircle(position.x, position.y, 2.0f, color);
  }
}

cells: std::vector<Cell> = ();

window_width: int = 1080;
window_height: int = 720;

running: std::atomic<bool> = true;

create_random_cell: (config: Config) -> Cell = {
  rw := cpp2::unsafe_narrow<float>(GetRandomValue(0, window_width));
  rh := cpp2::unsafe_narrow<float>(GetRandomValue(0, window_height));
  return Cell(rw as float, rh as float, config);
}

update_cells : (from: ssize_t, to: ssize_t, config: Config) -> void = {
  while (running)
  {
    i := from; while i < to next i += 1 {
      cells[i].update(config);
    }

    std::this_thread::sleep_for(std::chrono::milliseconds(0));
  }
}

main: () = {
  window_name := "Hello, cppfront";
  InitWindow(window_width, window_height, window_name);
  SetTargetFPS(170);

  config := Config();
  gui := GUI();

  config.attraction_matrix = config.generate_attraction_matrix(config.colors_number);

  std::cout << "Hello, cppfront!\n";

  cell_num := 1000; while cell_num > 0 next cell_num -= 1 {    
    cells.push_back(create_random_cell(config));
  }

  frame: u64 = 0;
  num_threads : const _ = std::max(1 as ssize_t, std::thread::hardware_concurrency() - 1 as ssize_t);
  threads: std::vector<std::thread> = ();

  if (num_threads > 0)
  {
    i := 0 as ssize_t; while i < num_threads next i += 1 {
      from := (cells.ssize() / num_threads) * i;
      to := (cells.ssize() / num_threads) * (i + 1);
      threads.push_back(std::thread(update_cells, from, to, config));
    }
  }

  while !WindowShouldClose()
  {
    frame += 1;

    if (num_threads == 0)
    {
      for cells do (inout cell)
      {
        cell.update(config);
      }
    }

    if (frame % 10000 == 0)
    {
      for cells do (in cell)
      {
        cell.print_xy();
      }
    }

    window_width = GetRenderWidth();
    window_height = GetRenderHeight();

    if IsKeyDown(KEY_R) || IsKeyDown(KEY_SPACE)
    {
      cells.push_back(create_random_cell(config));
    }

    if IsMouseButtonDown(MOUSE_BUTTON_RIGHT)
    {
      cell := Cell(cpp2::unsafe_narrow<float>(GetMouseX()), cpp2::unsafe_narrow<float>(GetMouseY()), config);
      cells.push_back(cell);
    }

    BeginDrawing();
    //DrawRectangle(0, 0, window_width, window_height, ColorAlpha(BLACK, 0.5f));
    DrawRectangle(0, 0, window_width, window_height, BLACK);

    for cells do (in cell) {
      cell.draw(config);
    }
    gui.draw(config);

    EndDrawing();
  }

  running = false;

  for threads do (inout thread) {
    thread.join();
  }

  CloseWindow();
}

print_xy: (cell: Cell) = {
  std::cout << "cell.position = " << cell.position << "\n";
}
